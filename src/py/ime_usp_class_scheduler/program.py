from abc import ABC, abstractmethod
from collections import deque
from pathlib import Path

import rich
from clingo import Model, SolveResult
from rich.json import JSON

from ime_usp_class_scheduler.configuration import Configuration
from ime_usp_class_scheduler.constants import (
    CONSTRAINTS_DIR,
    HARD_CONSTRAINTS_DIR,
    SOFT_CONSTRAINTS_DIR,
)
from ime_usp_class_scheduler.log import CONSOLE, LOG_INFO, LOG_WARN
from ime_usp_class_scheduler.model.input import InputDataset
from ime_usp_class_scheduler.model.output import ModelResult
from ime_usp_class_scheduler.solver import CliSolver, Solver
from ime_usp_class_scheduler.view import CliTabularView, ModelView


class Program(ABC):
    """A program to run, interact and display the results of a Solver."""

    _solver: Solver
    _model_viewer: ModelView

    @abstractmethod
    def start(self) -> None:
        """Starts the program."""
        ...

    def save_program(self, path: Path) -> None:
        """Write solver program to a file."""
        with open(path, "w") as f:
            f.write(self._solver.program)

    def _on_model(self, model: Model) -> None:
        """Callback for intercepting models generated by the Solver."""
        self._model_viewer.show_model(ModelResult.from_model(model))

    def _on_finish(self, result: SolveResult) -> None:
        """Callback called once the search has concluded."""
        pass


class CliProgram(Program):
    """A commandline interface solver program."""

    _BASE_MODEL_PATHS = [
        CONSTRAINTS_DIR.joinpath(path).with_suffix(".lp")
        for path in ("aliases", "base")
    ]

    def __init__(self, configuration: Configuration, dump_symbols: bool) -> None:
        self._solver = CliSolver(configuration)
        self._model_viewer = CliTabularView()
        self._best_models: deque[ModelResult] = deque(
            maxlen=configuration.clingo.num_models
        )
        self._hard_constraints = configuration.constraints.hard
        self._soft_constraints = configuration.constraints.soft
        self._dump_symbols = dump_symbols

        input_dataset = self._load_inputs()
        input_dataset.validate_and_normalize()
        self._solver.load_input(input_dataset)

        model = self._load_model()
        self._solver.load_model(model)

    def start(self) -> None:
        """Starts the program."""
        CONSOLE.rule("solving")
        with CONSOLE.status("[bold green]Searching for models..."):
            self._solver.run(on_model=self._on_model, on_finish=self._on_finish)

    def _on_model(self, model: Model) -> None:
        """Callback for intercepting models generated by the Solver."""
        LOG_INFO(f"Current optimization: {model.cost}")
        self._best_models.append(ModelResult.from_model(model))

    def _on_finish(self, result: SolveResult) -> None:
        """Callback called once the search has concluded."""
        CONSOLE.rule("results")

        if result.interrupted:
            LOG_WARN("Search interrupted before completion.")

        LOG_INFO(f"Solving status: {result}")
        LOG_INFO(f"Showing top {len(self._best_models)} results:")

        for model in self._best_models:
            self._model_viewer.show_model(model)

        if self._dump_symbols:
            rich.print(JSON.from_data(self._model_viewer.symbols))

    def _load_inputs(self) -> InputDataset:
        """Loads and validates the scheduler inputs."""
        return InputDataset.from_default_files()

    def _load_model(self) -> str:
        """Load the ASP model (base + hard and soft constraints) based on user configuration."""
        model = ""

        # Load constraints
        paths = self._BASE_MODEL_PATHS.copy()
        paths += [
            HARD_CONSTRAINTS_DIR.joinpath(constraint_cfg.path)
            for constraint_cfg in self._hard_constraints
        ]
        paths += [
            SOFT_CONSTRAINTS_DIR.joinpath(constraint_cfg.path)
            for constraint_cfg in self._soft_constraints
        ]

        try:
            for path in paths:
                with open(path) as f:
                    model += f.read() + "\n"
        except FileNotFoundError as e:
            raise FileNotFoundError(f"Unable to find constraint file {e.filename}.")

        # Setup weights and and priorities
        for soft_cfg in self._soft_constraints:
            weight = f"#const w_{soft_cfg.name} = {soft_cfg.weight}.\n"
            priority = f"#const p_{soft_cfg.name} = {soft_cfg.priority}.\n"
            model += weight + priority

        return model
