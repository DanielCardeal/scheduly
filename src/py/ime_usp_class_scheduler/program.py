import json
from abc import ABC, abstractmethod
from collections import deque
from typing import IO, Any

import rich
from clingo import Model, SolveResult, Symbol, SymbolType

from ime_usp_class_scheduler.log import CONSOLE, LOG_INFO, LOG_WARN
from ime_usp_class_scheduler.model.configuration import Configuration
from ime_usp_class_scheduler.model.input import InputDataset
from ime_usp_class_scheduler.model.output import ModelResult
from ime_usp_class_scheduler.solver import CliSolver, Solver
from ime_usp_class_scheduler.view import CliTabularView


class Program(ABC):
    """A program to run, interact and display the results of a Solver."""

    _solver: Solver

    @abstractmethod
    def start(self) -> None:
        """Starts the program."""
        ...

    @abstractmethod
    def _on_model(self, model: Model) -> None:
        """Callback for intercepting models generated by the Solver."""
        ...

    @abstractmethod
    def _on_finish(self, result: SolveResult) -> None:
        """Callback called once the search has concluded."""
        ...

    def save_program(self, file: IO[str]) -> None:
        """Write solver program to a file."""
        file.write(self._solver.program)


class CliProgram(Program):
    """A commandline interface solver program."""

    def __init__(
        self,
        configuration: Configuration,
        dump_symbols: bool,
    ) -> None:
        self._solver = CliSolver(
            configuration.options,
            inputs=InputDataset.from_default_files(),
            constraints=configuration.constraints,
        )
        self._model_viewer = CliTabularView()
        self._best_models: deque[ModelResult] = deque(
            maxlen=configuration.options.num_models
        )
        self._dump_symbols = dump_symbols

    def start(self) -> None:
        """Starts the program."""
        CONSOLE.rule("solving")
        with CONSOLE.status("[bold green]Searching for models..."):
            self._solver.run(on_model=self._on_model, on_finish=self._on_finish)

    def _on_model(self, model: Model) -> None:
        """Callback for intercepting models generated by the Solver."""
        LOG_INFO(f"Current optimization: {model.cost}")
        self._best_models.append(ModelResult.from_model(model))

    def _on_finish(self, result: SolveResult) -> None:
        """Callback called once the search has concluded."""
        CONSOLE.rule("results")

        if result.interrupted:
            LOG_WARN("Search interrupted before completion.")

        LOG_INFO(f"Solving status: {result}")
        LOG_INFO(f"Showing top {len(self._best_models)} results:")

        for model in self._best_models:
            self._model_viewer.show_model(model)

        if self._dump_symbols:
            json_str = self._dump_json()
            rich.print_json(json_str)

    def _dump_json(self) -> str:
        """Encode symbols of the best models into a JSON string."""
        json_data = []

        for idx, model in enumerate(self._best_models):
            model_data: dict[str, Any] = {}
            model_data["index"] = idx
            model_data["cost"] = model.cost

            for symbol in model.symbols:
                if symbol.name not in model_data:
                    model_data[symbol.name] = []
                symbol_list_repr = _get_symbol_arguments(symbol)
                model_data[symbol.name].append(symbol_list_repr)

            json_data.append(model_data)

        return json.dumps(json_data)


def _get_symbol_arguments(symbol: Symbol) -> list[str | int]:
    """Get arguments of a clingo function as a list."""
    args: list[str | int] = []
    for arg in symbol.arguments:
        match arg.type:
            case SymbolType.Number:
                args.append(arg.number)
            case SymbolType.String:
                args.append(arg.string)
    return args
