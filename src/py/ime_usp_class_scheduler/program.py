from abc import ABC, abstractmethod
from collections import deque
from pathlib import Path

import rich
from clingo import Model, SolveResult
from rich.json import JSON

from ime_usp_class_scheduler.log import CONSOLE, LOG_INFO, LOG_WARN
from ime_usp_class_scheduler.model.configuration import Configuration
from ime_usp_class_scheduler.model.input import InputDataset
from ime_usp_class_scheduler.model.output import ModelResult
from ime_usp_class_scheduler.solver import CliSolver, Solver
from ime_usp_class_scheduler.view import CliTabularView, ModelView


class Program(ABC):
    """A program to run, interact and display the results of a Solver."""

    _solver: Solver
    _model_viewer: ModelView

    @abstractmethod
    def start(self) -> None:
        """Starts the program."""
        ...

    def save_program(self, path: Path) -> None:
        """Write solver program to a file."""
        with open(path, "w") as f:
            f.write(self._solver.program)

    def _on_model(self, model: Model) -> None:
        """Callback for intercepting models generated by the Solver."""
        self._model_viewer.show_model(ModelResult.from_model(model))

    def _on_finish(self, result: SolveResult) -> None:
        """Callback called once the search has concluded."""
        pass


class CliProgram(Program):
    """A commandline interface solver program."""

    def __init__(self, configuration: Configuration, dump_symbols: bool) -> None:
        self._solver = CliSolver(
            configuration.options,
            inputs=InputDataset.from_default_files(),
            constraints=configuration.constraints,
        )
        self._model_viewer = CliTabularView()
        self._best_models: deque[ModelResult] = deque(
            maxlen=configuration.options.num_models
        )
        self._dump_symbols = dump_symbols

    def start(self) -> None:
        """Starts the program."""
        CONSOLE.rule("solving")
        with CONSOLE.status("[bold green]Searching for models..."):
            self._solver.run(on_model=self._on_model, on_finish=self._on_finish)

    def _on_model(self, model: Model) -> None:
        """Callback for intercepting models generated by the Solver."""
        LOG_INFO(f"Current optimization: {model.cost}")
        self._best_models.append(ModelResult.from_model(model))

    def _on_finish(self, result: SolveResult) -> None:
        """Callback called once the search has concluded."""
        CONSOLE.rule("results")

        if result.interrupted:
            LOG_WARN("Search interrupted before completion.")

        LOG_INFO(f"Solving status: {result}")
        LOG_INFO(f"Showing top {len(self._best_models)} results:")

        for model in self._best_models:
            self._model_viewer.show_model(model)

        if self._dump_symbols:
            rich.print(JSON.from_data(self._model_viewer.symbols))
