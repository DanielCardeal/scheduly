from abc import ABC, abstractmethod
from collections import deque
from pathlib import Path

from clingo import Model, SolveResult

from ime_usp_class_scheduler.configuration import Configuration
from ime_usp_class_scheduler.constants import (
    CONSTRAINTS_DIR,
    HARD_CONSTRAINTS_DIR,
    INPUT_DIR,
    SOFT_CONSTRAINTS_DIR,
)
from ime_usp_class_scheduler.model import (
    IntoASP,
    ModelResult,
    TeacherData,
    WorkloadData,
    generate_full_availability,
)
from ime_usp_class_scheduler.parser import (
    ime_parse_schedule,
    ime_parse_workload,
    parse_courses,
    parse_curricula,
    parse_joint,
)
from ime_usp_class_scheduler.solver import DefaultSolver, Solver
from ime_usp_class_scheduler.terminal import CONSOLE, LOG_INFO, LOG_WARN
from ime_usp_class_scheduler.view import CliTabularView, ModelView


class Program(ABC):
    """A program to run, interact and display the results of a Solver."""

    def __init__(
        self,
        configuration: Configuration,
        solver: type[Solver],
        model_viewer: type[ModelView],
    ) -> None:
        self._solver = solver(configuration)
        self._model_viewer = model_viewer()

    @abstractmethod
    def start(self) -> None:
        """Starts the program."""
        ...

    def save_model(self, path: Path) -> None:
        """Write solver model to path."""
        with open(path, "w") as f:
            f.write(self._solver.model)

    @abstractmethod
    def _on_model(self, model: Model) -> None:
        """Callback for intercepting models generated by the Solver."""
        ...

    @abstractmethod
    def _on_finish(self, result: SolveResult) -> None:
        """Callback called once the search has concluded."""
        ...


class CliProgram(Program):
    """A commandline interface solver program."""

    _BASE_MODEL_PATHS = [
        CONSTRAINTS_DIR.joinpath(path).with_suffix(".lp")
        for path in ("aliases", "base")
    ]

    def __init__(self, configuration: Configuration) -> None:
        super().__init__(
            configuration=configuration,
            solver=DefaultSolver,
            model_viewer=CliTabularView,
        )
        self._best_models: deque[ModelResult] = deque(
            maxlen=configuration.clingo.num_models
        )
        self._hard_constraints = configuration.constraints.hard
        self._soft_constraints = configuration.constraints.soft

        # Load ASP program
        def header(header: str) -> str:
            return f"\n% --- {header.upper()} --- \n"

        program = ""

        program += header("inputs")
        raw_inputs = self._load_inputs()
        asp_inputs = "\n".join((input.into_asp() for input in raw_inputs))
        program += asp_inputs

        program += header("model")
        program += self._load_model()

        self._solver.load(program)

    def start(self) -> None:
        """Starts the program."""
        CONSOLE.rule("solving")
        with CONSOLE.status("[bold green]Searching for models..."):
            self._solver.run(on_model=self._on_model, on_finish=self._on_finish)

    def _on_model(self, model: Model) -> None:
        """Callback for intercepting models generated by the Solver."""
        LOG_INFO(f"Current optimization: {model.cost}")
        # LOG_INFO(f"{[str(s) for s in model.symbols(shown=True)]}")
        self._best_models.append(ModelResult.from_model(model))

    def _on_finish(self, result: SolveResult) -> None:
        """Callback called once the search has concluded."""
        CONSOLE.rule("results")

        if result.interrupted:
            LOG_WARN("Search interrupted before completion.")

        LOG_INFO(f"Solving status: {result}")
        LOG_INFO(f"Showing top {len(self._best_models)} results:")

        for model in self._best_models:
            self._model_viewer.show_model(model)

    def _load_inputs(self) -> list[IntoASP]:
        """
        Import data from INPUT_DIR using the appropriate parsers.

        This function might add some extra information that is implied by the
        data loaded from the parsers, for example, it adds full availability
        for teachers with no available teaching periods.
        """
        input_data: list[IntoASP] = []

        def input_fpath(fname: str) -> Path:
            return INPUT_DIR.joinpath(fname)

        try:
            with open(input_fpath("courses.csv")) as f:
                input_data += parse_courses(f)

            with open(input_fpath("curricula.csv")) as cf, open(
                input_fpath("curricula_components.csv")
            ) as ccf:
                input_data += parse_curricula(cf, ccf)

            with open(input_fpath("joint.csv")) as jf:
                input_data += parse_joint(jf)

            with open(input_fpath("schedule.csv")) as wf:
                input_data += ime_parse_schedule(wf)

            with open(input_fpath("workload.csv")) as wf:
                input_data += ime_parse_workload(wf)
        except FileNotFoundError as e:
            raise FileNotFoundError(f"Unable to find required input file {e.filename}.")

        # Add full availability for lecturers without availability information
        full_availability = generate_full_availability()

        lecturers = set()
        for teacher in input_data:
            match teacher:
                case WorkloadData(teacher_id=teacher_id):
                    lecturers.add(teacher_id)

        for idx, teacher in enumerate(input_data):
            if not isinstance(teacher, TeacherData):
                continue
            elif len(teacher.available_time) > 0:
                lecturers.remove(teacher.teacher_id)
            else:
                input_data[idx] = TeacherData(
                    teacher.teacher_id, full_availability, teacher.preferred_time
                )
                lecturers.remove(teacher.teacher_id)

        for teacher_id in lecturers:  # Teachers with no associated TeacherData
            input_data.append(TeacherData(teacher_id, full_availability, set()))

        return input_data

    def _load_model(self) -> str:
        """Load the ASP model (base + hard and soft constraints) based on user configuration."""
        model = ""

        # Load constraints
        paths = self._BASE_MODEL_PATHS.copy()
        paths += [
            HARD_CONSTRAINTS_DIR.joinpath(constraint_cfg.path)
            for constraint_cfg in self._hard_constraints
        ]
        paths += [
            SOFT_CONSTRAINTS_DIR.joinpath(constraint_cfg.path)
            for constraint_cfg in self._soft_constraints
        ]

        try:
            for path in paths:
                with open(path) as f:
                    model += f.read() + "\n"
        except FileNotFoundError as e:
            raise FileNotFoundError(f"Unable to find constraint file {e.filename}.")

        # Setup weights and and priorities
        for soft_cfg in self._soft_constraints:
            weight = f"#const w_{soft_cfg.name} = {soft_cfg.weight}.\n"
            priority = f"#const p_{soft_cfg.name} = {soft_cfg.priority}.\n"
            model += weight + priority

        return model
