"""Dataclasses that model results from a scheduler run."""
from typing import Protocol, Sequence

from attrs import frozen
from clingo import Model, Symbol, SymbolType
from typing_extensions import Self

from ime_usp_class_scheduler.model.common import Period, Weekday


class ClingoOutput(Protocol):
    """Objects that can be parsed from an ASP symbol."""

    @classmethod
    def from_asp(cls, symbol: Symbol) -> Self:
        """Parse an ASP symbol into an instance of the class."""
        ...


@frozen
class JointedData:
    """Information about jointed courses in an ASP model."""

    course_id_a: str
    """First of the conflicting courses."""

    course_id_b: str
    """Second of the conflicting courses."""

    offering_group: str
    """The offering group of the conflicting classes"""

    @classmethod
    def from_asp(cls, symbol: Symbol) -> Self:
        """Parse JointedData from a `_joint/3` or a `joint/3` ASP predicate."""
        assert symbol.type is SymbolType.Function and symbol.name in (
            "joint",
            "_joint",
        ), f"Unable to construct JointedData object from the given symbol: {str(symbol)}"
        course_id_a = symbol.arguments[0].string
        course_id_b = symbol.arguments[1].string
        offering_group = symbol.arguments[2].string
        return cls(course_id_a, course_id_b, offering_group)


@frozen
class ClassData:
    """Information about a scheduled class in a ASP model."""

    course_id: str
    """Unique identifier for the classes' course."""

    offering_group: str
    """Unique identifier for the classes' offering group."""

    weekday: Weekday
    """Day of the week of the scheduled class."""

    period: Period
    """Period of the scheduled class."""

    @classmethod
    def from_asp(cls, symbol: Symbol) -> Self:
        """Parse ClassData from a `class/4` ASP predicate."""
        assert (
            symbol.type is SymbolType.Function and symbol.name == "class"
        ), f"Unable to construct ClassData object from the given symbol: {str(symbol)}"
        course_id = symbol.arguments[0].string
        group = symbol.arguments[1].string
        weekday = Weekday(symbol.arguments[2].number)
        period = Period(symbol.arguments[3].number)
        return cls(course_id, group, weekday, period)


@frozen
class ConflictData:
    """Information about conflicting classes from courses, A and B."""

    course_id_a: str
    """Course A unique identifier."""

    group_id_a: str
    """Course A offering group unique identifier."""

    course_id_b: str
    """Course B unique identifier."""

    group_id_b: str
    """Course B offering group unique identifier."""

    weekday: Weekday
    """Day of the week in which the conflict occurs."""

    period: Period
    """Teaching period in which the conflict occurs."""

    @classmethod
    def from_asp(cls, symbol: Symbol) -> Self:
        """Parse ConflictData from a `conflict/6` ASP predicate."""
        assert (
            symbol.type is SymbolType.Function and symbol.name == "conflict"
        ), f"Unable to construct ConflictData object from the given symbol: {str(symbol)}"
        course_id_a = symbol.arguments[0].string
        group_id_a = symbol.arguments[1].string
        course_id_b = symbol.arguments[2].string
        group_id_b = symbol.arguments[3].string
        weekday = Weekday(symbol.arguments[4].number)
        period = Period(symbol.arguments[5].number)
        return cls(course_id_a, group_id_a, course_id_b, group_id_b, weekday, period)


@frozen
class ModelResult:
    """Information about a model generated by the scheduler.

    Use this class instead of saving plain clingo.Models, since they are not
    safe to use outside the SolveHandle scope. Further information:
    https://github.com/potassco/clingo/issues/305
    """

    symbols: Sequence[Symbol]
    """Sequence of symbols gathered from the clingo model."""

    cost: list[int]
    """Optimization cost of the clingo model."""

    @classmethod
    def from_model(cls, model: Model) -> Self:
        """Extract a ModelResult from a clingo.Model."""
        symbols = model.symbols(shown=True)
        cost = model.cost
        return cls(symbols, cost)
